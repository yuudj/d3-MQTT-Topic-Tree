<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <link type="text/css" rel="stylesheet" href="topic-tree.css">
  <link type="text/css" rel="stylesheet" href="style.css" />

</head>

<body>
  <div id="status"></div>
  <script src="https://d3js.org/d3.v4.min.js"></script>
  <script type="text/javascript" src="mqttws31.js"></script>
  <script type="text/javascript" src="topic-tree.js"></script>

  <script type="text/javascript">
    var messages = {
      'home/cam1': 1,
      'home/cam2': 2,
      'home/cam3': 2,
      'home/cam4': 2,
      'work/office1/cam1': 2,
      'work/office2/cam1': 2
    };

    


    var keys = Object.keys(messages);
    var hobj = {};//indice para la busqueda
    var hobjArr = [{ name: 'root', parent: '', value: null }];

    //completa los keys con los roots
    keys.forEach(path => {
      var prevPath = 'root';
      var splited = path.split('/');;
      splited.forEach(element => {
        elementPath = prevPath + '/' + element;
        if (!hobj[elementPath]) {
          hobj[elementPath] = 1;
          hobjArr.push({ name: elementPath, parent: prevPath, value: messages[elementPath] || null });
        }
        prevPath = elementPath;
      });
    });

    keys.forEach(path => {
      var prevPath = 'root';

      var splited = path.split('/');;
      splited.forEach(element => {
        elementPath = prevPath + '/' + element;



        if (!hobj[elementPath]) {
          hobj[elementPath] = 1;
          hobjArr.push({ name: elementPath, parent: prevPath, value: messages[elementPath] || null });
        }

        prevPath = elementPath;
      });


    });




    var data = d3.stratify()
      .id(function (d) { return d.name; })
      .parentId(function (d) { return d.parent; })
      (hobjArr);



    // Set the dimensions and margins of the diagram
    var margin = { top: 20, right: 90, bottom: 30, left: 90 },
      width = 960 - margin.left - margin.right,
      height = 500 - margin.top - margin.bottom;

    // append the svg object to the body of the page
    // appends a 'group' element to 'svg'
    // moves the 'group' element to the top left margin
    var svg = d3.select("body").
      append("svg").
      attr("width", width + margin.right + margin.left).
      attr("height", height + margin.top + margin.bottom).
      append("g").
      attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    var i = 0, duration = 750, root;

    // declares a tree layout and assigns the size
    var treemap = d3.tree().size([height, width]);

    // Assigns parent, children, height, depth
    root = d3.hierarchy(data, function (d) {
      return d.children;
    });
    root.x0 = height / 2;
    root.y0 = 0;

    update(root);



    function update(source) {

      // Assigns the x and y position for the nodes
      var treeData = treemap(root);

      // Compute the new tree layout.
      var nodes = treeData.descendants(),
        links = treeData.descendants().slice(1);

      // Normalize for fixed-depth.
      nodes.forEach(function (d) {
        d.y = d.depth * 180
      });

      // ### LINKS

      // Update the links...
      var link = svg.selectAll('line.link').
        data(links, function (d) {
          return d.id;
        });

      // Enter any new links at the parent's previous position.
      var linkEnter = link.enter().
        append('line').
        attr("class", "link").
        attr("stroke-width", 2).
        attr("stroke", 'black').
        attr('x1', function (d) {
          return source.y0;
        }).
        attr('y1', function (d) {
          return source.x0;
        }).
        attr('x2', function (d) {
          return source.y0;
        }).
        attr('y2', function (d) {
          return source.x0;
        });

      var linkUpdate = linkEnter.merge(link);

      linkUpdate.transition().
        duration(duration).
        attr('x1', function (d) {
          return d.parent.y;
        }).
        attr('y1', function (d) {
          return d.parent.x;
        }).
        attr('x2', function (d) {
          return d.y;
        }).
        attr('y2', function (d) {
          return d.x;
        });

      // Transition back to the parent element position
      linkUpdate.transition().
        duration(duration).
        attr('x1', function (d) {
          return d.parent.y;
        }).
        attr('y1', function (d) {
          return d.parent.x;
        }).
        attr('x2', function (d) {
          return d.y;
        }).
        attr('y2', function (d) {
          return d.x;
        });

      // Remove any exiting links
      var linkExit = link.exit().
        transition().
        duration(duration).
        attr('x1', function (d) {
          return source.x;
        }).
        attr('y1', function (d) {
          return source.y;
        }).
        attr('x2', function (d) {
          return source.x;
        }).
        attr('y2', function (d) {
          return source.y;
        }).
        remove();

      // ### CIRCLES

      // Update the nodes...
      var node = svg.selectAll('g.node')
        .data(nodes, function (d) {
          return d.id || (d.id = ++i);
        });

      // Enter any new modes at the parent's previous position.
      var nodeEnter = node.enter().
        append('g')
        .attr('id', function (d) {
          return d.data.id;
        })
        .attr('class', 'node').
        attr("transform", function (d) {
          return "translate(" + source.y0 + "," + source.x0 + ")";
        }).
        on('click', click);

      // Add Circle for the nodes
      nodeEnter.append('circle').
        attr('class', 'node').
        attr('r', 25).
        style("fill", function (d) {
          return "#0e4677";
        });

      // Update
      var nodeUpdate = nodeEnter.merge(node);

      // Transition to the proper position for the node
      nodeUpdate.transition().
        duration(duration).
        attr("transform", function (d) {
          return "translate(" + d.y + "," + d.x + ")";
        });

      // Update the node attributes and style
      nodeUpdate.select('circle.node').
        attr('r', 25).
        style("fill", function (d) {
          return "#0e4677";
        }).
        attr('cursor', 'pointer');

      // Remove any exiting nodes
      var nodeExit = node.exit().
        transition().
        duration(duration).
        attr("transform", function (d) {
          return "translate(" + source.y + "," + source.x + ")";
        }).
        remove();

      // On exit reduce the node circles size to 0
      nodeExit.select('circle').attr('r', 0);

      // Store the old positions for transition.
      nodes.forEach(function (d) {
        d.x0 = d.x;
        d.y0 = d.y;
      });

      // Toggle children on click.
      function click(d) {
        // selected = d;
        // document.getElementById('add-child').disabled = false;
        // document.getElementById('remove').disabled = false;
        update(d);
      }
    }

    function addNode(parent, nodeData) {
      debugger;
      //creates New OBJECT
      var newNodeObj = {
        if: nodeData.name,
        name: nodeData.name,
        attributes: [],
        children: [],
        data: nodeData
      };
      //Creates new Node 
      var newNode = d3.hierarchy(newNodeObj);
      newNode.depth = parent.depth + 1;
      newNode.height = parent.height - 1;
      newNode.parent = parent;
      newNode.id = Date.now();

      if (!parent.children) {
        parent.children = [];
        parent.data.children = [];
      }
      parent.children.push(newNode);
      //parent.data.children.push(newNode.data);

      update(parent);
    };


    //ver http://bl.ocks.org/sim0nf/3317686
    //https://jsfiddle.net/a6pLqpxw/8/


    var options = {
      host: 'iot.eclipse.org',//location.hostname,
      port: 80,
      clientID: "web" + new Date().getTime(),
      connectOpts: {
        // userName: '',
        // password: '',
        // useSSL: true,
        keepAliveInterval: 30,
        timeout: 10,
        cleanSession: false,
        onSuccess: onConnect,
        onFailure: onFailure
      }
    }


    var client = new Paho.MQTT.Client(options.host, options.port, '/ws', options.clientID);
    client.onMessageArrived = onMessage;
    client.onconnectionlost = onDisconnect;

    function onConnect() {
      client.subscribe('#', onMessage);
      document.getElementById('status').innerHTML = "";
      console.log("mqtt connected");
    }

    function onFailure() {
      document.getElementById('status').innerHTML = "failed to connect";
      reconnect();
    }

    client.connect(options.connectOpts);

    function onMessage(message) {

      try {
        messages[message.topic] = message.payloadString;
        var prevPath = 'root';

        message.topic.split('/').forEach(element => {
          elementPath = prevPath + '/' + element;
          var parentNode = d3.select('#' + prevPath);
          
          if (!parentNode.empty()) {
            debugger;
            addNode(parentNode._groups[0][0], { name: elementPath, parent: prevPath, value: messages[elementPath] || null })
          }

          prevPath = elementPath;

        });

      } catch (error) {
        
      }


      //console.log(message.topic + "- " + message.payload);
      //addNode(message.destinationName, message.payloadString);
    }

    function onDisconnect(reason) {
      console.log("disconnected - " + reason);
      //alert("disconnected - " + reason);
      document.getElementById('status').innerHTML = "Disconnected";
      reconnect();
    }

    function reconnect() {
      setTimeout(function () {
        document.getElementById('status').innerHTML = "reconnecting";
        client.connect(options.connectOpts);
      }, 3000);
    }
  </script>
</body>

</html>